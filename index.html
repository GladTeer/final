<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>EFA</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="index_files/libs/clipboard/clipboard.min.js"></script>
<script src="index_files/libs/quarto-html/quarto.js"></script>
<script src="index_files/libs/quarto-html/popper.min.js"></script>
<script src="index_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="index_files/libs/quarto-html/anchor.min.js"></script>
<link href="index_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="index_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="index_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="index_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="index_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">EFA</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="load-data-and-packages" class="level1">
<h1>Load Data and Packages</h1>
<p>Just by looking at the tests, you can see they are designed to assess three kinds of abilities: visual perception, verbal comprehension, and processing speed. Each construct is measured by three different tests — a strategy known as triangulation. This is important because someone might be very skilled at identifying 2D shapes but less adept at perceiving 3D spatial relations. Yet both skills are part of the broader construct of visual perception. Similarly, one test may be noisier for certain individuals than another. By including multiple tests per construct, we reduce the influence of measurement error and obtain a more reliable estimate of the underlying ability.</p>
</section>
<section id="pca-vs-efa" class="level1">
<h1>PCA vs EFA</h1>
<p>Before diving in, it’s important to note that EFA and PCA often yield similar results, especially when applied to correlation matrices. In both methods, we aren’t concerned with the absolute values of test scores; what matters are the <strong>relationships</strong> between scores — in other words, the <strong>correlations</strong>, not the raw data.</p>
<p>However, PCA and EFA serve <strong>different purposes</strong>:</p>
<ul>
<li><p><strong>PCA</strong> is a data reduction technique that aims to summarize as much of the total variance in the dataset as possible using fewer dimensions (principal components). The problem in psychological measurement is that test scores often include <strong>noise</strong>, and PCA does <strong>not separate</strong> that noise — it includes all variance, whether meaningful or not.</p></li>
<li><p><strong>EFA</strong>, on the other hand, is designed to identify <strong>latent constructs</strong> — the unobserved traits or abilities that underlie the measured variables. It explicitly models <strong>measurement error</strong>, separating common variance (from latent factors) from unique variance (including noise).</p></li>
</ul>
<p>You can think of PCA and EFA as different tools — like a ratchet and a wrench. Both are useful, but one may be better suited to a given situation.</p>
<p>Let’s start by running a PCA to demonstrate how components are constructed as <strong>linear combinations</strong> of the original variables.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>pca_res <span class="ot">&lt;-</span> <span class="fu">principal</span>(ability_data, <span class="at">nfactors =</span> <span class="dv">3</span>, <span class="at">rotate =</span> <span class="st">"none"</span>)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Standardized data</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">scale</span>(ability_data))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     VisualPerception      Cubes      Lozenges ParagraphComprehension
[1,]      -1.37261630  1.4114904 -1.6582223135             -0.6250018
[2,]       0.34054541 -0.7117410 -0.1108908633             -1.1976822
[3,]      -0.37327194 -0.7117410 -0.3319382133             -1.7703627
[4,]       0.34054541  1.4114904  0.6627748618             -0.3386615
[5,]      -0.08774502 -1.1363873 -1.2161276135             -0.3386615
[6,]       0.34054541 -0.9240642 -0.0003671883             -1.7703627
     SentenceCompletion WordMeaning SpeedAddition SpeedCountingDots
[1,]          1.0922114  -0.8213354    -0.7293009         0.2201464
[2,]         -1.0387915  -0.8213354    -0.3701523         0.7139174
[3,]         -2.0074293  -1.6036833    -0.8490170        -1.6068063
[4,]          0.1235737   0.2217952    -1.0884494        -0.2242475
[5,]         -0.2638814   0.3521866    -0.4499631         0.7632945
[6,]         -1.0387915  -1.2125093     0.1486178         1.1089342
     SpeedDiscrimination
[1,]           0.9780371
[2,]           2.5194858
[3,]          -0.9487737
[4,]          -0.5083598
[5,]           0.5376232
[6,]           2.1065977</code></pre>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># PC weights (used to calculate component scores)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>pca_res<span class="sc">$</span>weights</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                             PC1         PC2         PC3
VisualPerception       0.2046740  0.07683966  0.27166763
Cubes                  0.1211578  0.05292178  0.45511371
Lozenges               0.1483177  0.20108350  0.39745728
ParagraphComprehension 0.2381001 -0.27244873 -0.12407810
SentenceCompletion     0.2293113 -0.29514696 -0.15889073
WordMeaning            0.2400747 -0.26166927 -0.08320530
SpeedAddition          0.1084450  0.30558558 -0.43295423
SpeedCountingDots      0.1412309  0.37463185 -0.24163380
SpeedDiscrimination    0.1836452  0.31233455 -0.01449535</code></pre>
</div>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># PC loadings (correlations between variables and components)</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>pca_res<span class="sc">$</span>loadings</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Loadings:
                       PC1    PC2    PC3   
VisualPerception        0.658  0.126  0.371
Cubes                   0.390         0.621
Lozenges                0.477  0.330  0.543
ParagraphComprehension  0.766 -0.446 -0.169
SentenceCompletion      0.738 -0.484 -0.217
WordMeaning             0.772 -0.429 -0.114
SpeedAddition           0.349  0.501 -0.591
SpeedCountingDots       0.454  0.614 -0.330
SpeedDiscrimination     0.591  0.512       

                 PC1   PC2   PC3
SS loadings    3.216 1.639 1.365
Proportion Var 0.357 0.182 0.152
Cumulative Var 0.357 0.539 0.691</code></pre>
</div>
</div>
<p>Focus on the loadings. Here, 9 variables are represented by 3 components. Squint a little, you can see there are 3 unique measurements loaded on each PCs</p>
<p>You can look at each participant’s PC score, but PC scores are not truthful</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># PC scores for each subject</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(pca_res<span class="sc">$</span>scores)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>             PC1         PC2         PC3
[1,] -0.31979345 -0.13629287 -0.16885100
[2,] -0.23015851  1.75528929  0.05774923
[3,] -1.97195792  0.20361540  0.88439686
[4,]  0.09689863 -0.34350545  1.53506310
[5,] -0.23487335  0.08294066 -0.96715408
[6,] -0.43353504  2.20221687 -0.20541681</code></pre>
</div>
</div>
<p>you can also calculate the PC scores by multiplying the weights with the data essentially, for each subj’s PC scores, you multiply each variable with its corresponding weight, then sum them together. This is a more explicit calculation that results in the same thing as above This shows that the original data can PERFECTLY reproduce the PC scores.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Manually compute PC scores</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">scale</span>(ability_data) <span class="sc">%*%</span> pca_res<span class="sc">$</span>weights)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>             PC1         PC2         PC3
[1,] -0.31979345 -0.13629287 -0.16885100
[2,] -0.23015851  1.75528929  0.05774923
[3,] -1.97195792  0.20361540  0.88439686
[4,]  0.09689863 -0.34350545  1.53506310
[5,] -0.23487335  0.08294066 -0.96715408
[6,] -0.43353504  2.20221687 -0.20541681</code></pre>
</div>
</div>
<p>Now do this the other way, try to reproduce the data from the PC scores</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Reconstruct standardized data from scores × loadings</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(pca_res<span class="sc">$</span>scores <span class="sc">%*%</span> <span class="fu">t</span>(<span class="fu">as.matrix</span>(pca_res<span class="sc">$</span>loadings)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     VisualPerception      Cubes   Lozenges ParagraphComprehension
[1,]      -0.29030411 -0.2413462 -0.2890827            -0.15545048
[2,]       0.09092644  0.0984154  0.4999391            -0.96971583
[3,]      -0.94450899 -0.2013066 -0.3937419            -1.75086055
[4,]       0.58984322  0.9617088  0.7659470            -0.03244939
[5,]      -0.50286190 -0.6852293 -0.6094842            -0.05307617
[6,]      -0.08428071 -0.1055841  0.4073991            -1.28042490
     SentenceCompletion WordMeaning SpeedAddition SpeedCountingDots
[1,]        -0.13331655 -0.16931055   -0.07999418        -0.1732387
[2,]        -1.03124388 -0.93694909    0.76457993         0.9539984
[3,]        -1.74472247 -1.71044022   -1.10857217        -1.0624887
[4,]        -0.09536505  0.04775145   -1.04551970        -0.6732361
[5,]        -0.00355812 -0.10706790    0.53124884         0.2632617
[6,]        -1.34032094 -1.25573918    1.07299424         1.2228006
     SpeedDiscrimination
[1,]          -0.2553082
[2,]           0.7613144
[3,]          -1.0780538
[4,]          -0.1489571
[5,]          -0.0771420
[6,]           0.8751439</code></pre>
</div>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compare with original standardized data</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">scale</span>(ability_data))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>     VisualPerception      Cubes      Lozenges ParagraphComprehension
[1,]      -1.37261630  1.4114904 -1.6582223135             -0.6250018
[2,]       0.34054541 -0.7117410 -0.1108908633             -1.1976822
[3,]      -0.37327194 -0.7117410 -0.3319382133             -1.7703627
[4,]       0.34054541  1.4114904  0.6627748618             -0.3386615
[5,]      -0.08774502 -1.1363873 -1.2161276135             -0.3386615
[6,]       0.34054541 -0.9240642 -0.0003671883             -1.7703627
     SentenceCompletion WordMeaning SpeedAddition SpeedCountingDots
[1,]          1.0922114  -0.8213354    -0.7293009         0.2201464
[2,]         -1.0387915  -0.8213354    -0.3701523         0.7139174
[3,]         -2.0074293  -1.6036833    -0.8490170        -1.6068063
[4,]          0.1235737   0.2217952    -1.0884494        -0.2242475
[5,]         -0.2638814   0.3521866    -0.4499631         0.7632945
[6,]         -1.0387915  -1.2125093     0.1486178         1.1089342
     SpeedDiscrimination
[1,]           0.9780371
[2,]           2.5194858
[3,]          -0.9487737
[4,]          -0.5083598
[5,]           0.5376232
[6,]           2.1065977</code></pre>
</div>
</div>
<p>Naturally, when we reduce dimensionality, we can’t perfectly reproduce the original data. The key takeaway is that principal component (PC) scores are calculated by multiplying the standardized data by the component weights, while the original data can be approximately reconstructed by multiplying PC scores by the loadings. It’s important not to confuse loadings with weights.</p>
</section>
<section id="pca-on-a-correlation-matrix" class="level1">
<h1>PCA on a Correlation Matrix</h1>
<p>Keep in mind that it is the relationships between the measurement that matters in PCA. Not the raw data. You can put a correlation matrix of the data in this function and it will give you the same results.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>cor_mat <span class="ot">&lt;-</span> <span class="fu">cor</span>(ability_data)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>pca_res <span class="ot">&lt;-</span> <span class="fu">principal</span>(cor_mat, <span class="at">nfactors =</span> <span class="dv">3</span>, <span class="at">rotate =</span> <span class="st">"none"</span>, <span class="at">covar =</span> <span class="cn">FALSE</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>pca_res<span class="sc">$</span>loadings</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Loadings:
                       PC1    PC2    PC3   
VisualPerception        0.658  0.126  0.371
Cubes                   0.390         0.621
Lozenges                0.477  0.330  0.543
ParagraphComprehension  0.766 -0.446 -0.169
SentenceCompletion      0.738 -0.484 -0.217
WordMeaning             0.772 -0.429 -0.114
SpeedAddition           0.349  0.501 -0.591
SpeedCountingDots       0.454  0.614 -0.330
SpeedDiscrimination     0.591  0.512       

                 PC1   PC2   PC3
SS loadings    3.216 1.639 1.365
Proportion Var 0.357 0.182 0.152
Cumulative Var 0.357 0.539 0.691</code></pre>
</div>
</div>
<p>Although PCA scores may seem useful, it’s usually not ideal to use them as psychological scales, because they include all variance — including measurement error. In psychological testing, where measurements are rarely noise-free, this can be a serious issue. Unless your measurements are as precise as a ruler, it’s better to use a method that models measurement error explicitly. That’d be Factor Analysis. The family FA comes in Exploratory Factor Analysis (EFA), EFA with target rotation, Item Response Theory (IRT), Confirmatory Factor Analysis (CFA), Structural Equation Modeling (SEM- obviously the pinnacle of statistic modeling)… That I am aware of. Ordered from the most exploratory to the most confirmatory methods (In my opinion).</p>
<p>Here, we will run Exploratory Factor Analysis (EFA) to identify the underlying constructs.</p>
</section>
<section id="exploratory-factor-analysis-efa" class="level1">
<h1>Exploratory Factor Analysis (EFA)</h1>
<p>PCA generates principal components directly from the data in a single algebraic step (Eigendecomposition). All variance are absorbed by the PCs.</p>
<p>Factor Analysis (FA), on the other hand, assumes that the data are generated from latent factors, and then tries to estimate both the factors and the factor loadings iteratively, such that the reconstructed data matches the observed correlations as closely as possible. Here, variances are separated into common variance (shared by the factors, interpreted as variance caused by latent constructs) and unique variance (specific to each variable, interpreted as variances caused by measurement error).</p>
<p>In EFA, we are not testing any model. We let the model build itself from the data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Run the EFA with 3 factors</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>efa_res <span class="ot">&lt;-</span> <span class="fu">fa</span>(cor_mat, <span class="at">nfactors =</span> <span class="dv">3</span>, <span class="at">rotate =</span> <span class="st">"none"</span>, <span class="at">fm =</span> <span class="st">"ml"</span>, <span class="at">covar =</span> <span class="cn">FALSE</span>)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(efa_res, <span class="at">digits =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Factor Analysis using method =  ml
Call: fa(r = cor_mat, nfactors = 3, rotate = "none", covar = FALSE, 
    fm = "ml")
Standardized loadings (pattern matrix) based upon correlation matrix
                        ML1   ML2   ML3   h2   u2 com
VisualPerception       0.49  0.31  0.39 0.49 0.51 2.7
Cubes                  0.24  0.17  0.40 0.25 0.75 2.1
Lozenges               0.27  0.41  0.47 0.46 0.54 2.6
ParagraphComprehension 0.83 -0.15 -0.03 0.72 0.28 1.1
SentenceCompletion     0.84 -0.21 -0.10 0.76 0.24 1.2
WordMeaning            0.82 -0.13  0.02 0.69 0.31 1.0
SpeedAddition          0.23  0.48 -0.46 0.50 0.50 2.4
SpeedCountingDots      0.27  0.62 -0.27 0.53 0.47 1.8
SpeedDiscrimination    0.38  0.56  0.02 0.46 0.54 1.8

                       ML1  ML2  ML3
SS loadings           2.72 1.31 0.82
Proportion Var        0.30 0.15 0.09
Cumulative Var        0.30 0.45 0.54
Proportion Explained  0.56 0.27 0.17
Cumulative Proportion 0.56 0.83 1.00

Mean item complexity =  1.8
Test of the hypothesis that 3 factors are sufficient.

df null model =  36  with the objective function =  3.05
df of  the model are 12  and the objective function was  0.08 

The root mean square of the residuals (RMSR) is  0.02 
The df corrected root mean square of the residuals is  0.03 

Fit based upon off diagonal values = 1
Measures of factor score adequacy             
                                                   ML1  ML2  ML3
Correlation of (regression) scores with factors   0.95 0.86 0.78
Multiple R square of scores with factors          0.90 0.73 0.60
Minimum correlation of possible factor scores     0.80 0.46 0.21</code></pre>
</div>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Factor structure diagram</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fa.diagram</span>(efa_res, <span class="at">simple =</span> <span class="cn">FALSE</span>, </span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>           <span class="at">main =</span> <span class="st">"EFA with 3 Factors"</span>, </span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>           <span class="at">errors =</span> <span class="cn">TRUE</span>, <span class="at">cut=</span> .<span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The output shows the factor loadings, which indicate how much each variable is associated with each factor. The higher the loading, the more that factor explain the manifest variable. Unlike PCA, where arrows point from observed data to components, in FA, arrows point from factors to observed variables. This is because we are assuming that the factors are the cause of the observed variables. And therefore, we call the numbers on the arrows loadings, instead of weights.</p>
<p>Overall, a pretty clear picture that: VisualPerception, Cubes, and Lozenges are all related to the same underlying factor. (Call it the Visual factor) SpeedAddition, SpeedCountingDots, and SpeedDiscrimination are all related to another factor.(Call it the Speed factor) ParagraphComprehension, SentenceCompletion, and WordMeaning are all related to a third factor. (Call it the Verbal factor)</p>
<p>There also seems to be some cross loadings such as Lozenges scores (Mental rotation) being influenced by the second factor (Speed factor). Not suprising because Response Time scales with how much an object is rotated in such tasks.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Residual correlation matrix</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>efa_res<span class="sc">$</span>residual</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>                       VisualPerception        Cubes     Lozenges
VisualPerception            0.512529527 -0.032413840 -0.001052342
Cubes                      -0.032413840  0.748735160  0.015419903
Lozenges                   -0.001052342  0.015419903  0.542773291
ParagraphComprehension      0.025792920 -0.011740983  0.008437338
SentenceCompletion         -0.012802788  0.009447472 -0.021060060
WordMeaning                -0.010859277  0.007156072  0.018372097
SpeedAddition              -0.018352282 -0.031014082  0.026340395
SpeedCountingDots           0.001746298  0.026662462 -0.015322624
SpeedDiscrimination         0.021492945  0.007299790 -0.013332417
                       ParagraphComprehension SentenceCompletion  WordMeaning
VisualPerception                  0.025792920       -0.012802788 -0.010859277
Cubes                            -0.011740983        0.009447472  0.007156072
Lozenges                          0.008437338       -0.021060060  0.018372097
ParagraphComprehension            0.279193094       -0.002092964 -0.001814919
SentenceCompletion               -0.002092964        0.242877321  0.003718852
WordMeaning                      -0.001814919        0.003718852  0.305215856
SpeedAddition                     0.042224137       -0.033119304  0.002442917
SpeedCountingDots                -0.031792510        0.016316693  0.011900139
SpeedDiscrimination              -0.019870262        0.031163678 -0.023957312
                       SpeedAddition SpeedCountingDots SpeedDiscrimination
VisualPerception       -0.0183522816      0.0017462983         0.021492945
Cubes                  -0.0310140822      0.0266624617         0.007299790
Lozenges                0.0263403951     -0.0153226243        -0.013332417
ParagraphComprehension  0.0422241374     -0.0317925097        -0.019870262
SentenceCompletion     -0.0331193037      0.0163166932         0.031163678
WordMeaning             0.0024429170      0.0119001389        -0.023957312
SpeedAddition           0.5022072219      0.0005075378        -0.006201658
SpeedCountingDots       0.0005075378      0.4685504898         0.005267924
SpeedDiscrimination    -0.0062016577      0.0052679244         0.543247686</code></pre>
</div>
</div>
<p>The residual matrix in EFA contains the VARIANCE of the residuals on the diagonal and the CORRELATION between the residuals on the off-diagonal. Ideally, these residual correlations should be low. High residual correlations suggest that the current factor model isn’t fully capturing the structure in the data. Meaning there may be additional latent factors that haven’t been modeled. For example, observed variables measured using similar formats (like pen-and-paper tests) may share variance due to shared method or modality, rather than due to the underlying psychological construct.</p>
</section>
<section id="factor-rotation" class="level1">
<h1>Factor Rotation</h1>
<p>A common practice in Exploratory Factor Analysis (EFA) is to rotate the factors after the initial solution is extracted. Rotation doesn’t change the underlying model or its fit. It only re-expresses the factor loadings to make them more interpretable. This step is performed after estimating the factor model, and its goal is to achieve what’s known as <strong>simple structure</strong> — a pattern in which each variable loads strongly on one factor and weakly on others. This makes it easier to assign meaningful labels to factors. Some rotation methods, like <strong>varimax</strong>, keep the factors uncorrelated (orthogonal), while others, like <strong>promax</strong>, allow them to correlate.</p>
<p>You might wonder why it’s okay to change the loadings after the model is fitted. A helpful analogy is to imagine the factor solution as a 3D object that’s been learned from the correlation matrix. The object doesn’t change, but you can view it from different angles. Each angle gives a different projection — and these projections are the rotated <strong>loadings</strong>.</p>
<section id="varimax-rotation-orthogonal-rotation" class="level2">
<h2 class="anchored" data-anchor-id="varimax-rotation-orthogonal-rotation">Varimax Rotation (Orthogonal Rotation)</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>efa_varimax <span class="ot">&lt;-</span> <span class="fu">fa</span>(cor_mat, <span class="at">nfactors =</span> <span class="dv">3</span>, <span class="at">rotate =</span> <span class="st">"varimax"</span>, <span class="at">fm =</span> <span class="st">"ml"</span>, <span class="at">covar =</span> <span class="cn">FALSE</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(efa_varimax, <span class="at">digits =</span> <span class="dv">2</span>, <span class="at">cutoff =</span> <span class="fl">0.3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Factor Analysis using method =  ml
Call: fa(r = cor_mat, nfactors = 3, rotate = "varimax", covar = FALSE, 
    fm = "ml")
Standardized loadings (pattern matrix) based upon correlation matrix
                        ML1   ML3   ML2   h2   u2 com
VisualPerception       0.28  0.62  0.15 0.49 0.51 1.5
Cubes                  0.10  0.49 -0.03 0.25 0.75 1.1
Lozenges               0.03  0.66  0.13 0.46 0.54 1.1
ParagraphComprehension 0.83  0.16  0.10 0.72 0.28 1.1
SentenceCompletion     0.86  0.09  0.09 0.76 0.24 1.0
WordMeaning            0.80  0.21  0.09 0.69 0.31 1.2
SpeedAddition          0.09 -0.07  0.70 0.50 0.50 1.1
SpeedCountingDots      0.05  0.16  0.71 0.53 0.47 1.1
SpeedDiscrimination    0.13  0.41  0.52 0.46 0.54 2.0

                       ML1  ML3  ML2
SS loadings           2.18 1.34 1.33
Proportion Var        0.24 0.15 0.15
Cumulative Var        0.24 0.39 0.54
Proportion Explained  0.45 0.28 0.27
Cumulative Proportion 0.45 0.73 1.00

Mean item complexity =  1.2
Test of the hypothesis that 3 factors are sufficient.

df null model =  36  with the objective function =  3.05 0.3
df of  the model are 12  and the objective function was  0.08 
 0.3
The root mean square of the residuals (RMSR) is  0.02 
The df corrected root mean square of the residuals is  0.03 
 0.3
Fit based upon off diagonal values = 1
Measures of factor score adequacy             
                                                   ML1  ML3  ML2
Correlation of (regression) scores with factors   0.93 0.81 0.84
Multiple R square of scores with factors          0.87 0.66 0.70
Minimum correlation of possible factor scores     0.74 0.33 0.40</code></pre>
</div>
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fa.diagram</span>(efa_varimax, <span class="at">simple =</span> <span class="cn">FALSE</span>, <span class="at">cut =</span> <span class="fl">0.4</span>, </span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>           <span class="at">main =</span> <span class="st">"EFA with 3 Factors - Varimax"</span>, </span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>           <span class="at">errors =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Varimax maximizes the variance of squared loadings per factor.</p>
<p>Produces a higher contrasted loading patterns, but forces factors to be uncorrelated.</p>
</section>
<section id="promax-rotation-oblique-rotation" class="level2">
<h2 class="anchored" data-anchor-id="promax-rotation-oblique-rotation">Promax Rotation (Oblique Rotation)</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>efa_promax <span class="ot">&lt;-</span> <span class="fu">fa</span>(cor_mat, <span class="at">nfactors =</span> <span class="dv">3</span>, <span class="at">rotate =</span> <span class="st">"promax"</span>, <span class="at">fm =</span> <span class="st">"ml"</span>, <span class="at">covar =</span> <span class="cn">FALSE</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(efa_promax, <span class="at">digits =</span> <span class="dv">2</span>, <span class="at">cutoff =</span> <span class="fl">0.3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Factor Analysis using method =  ml
Call: fa(r = cor_mat, nfactors = 3, rotate = "promax", covar = FALSE, 
    fm = "ml")
Standardized loadings (pattern matrix) based upon correlation matrix
                         ML1   ML2   ML3   h2   u2 com
VisualPerception        0.15  0.04  0.61 0.49 0.51 1.1
Cubes                   0.01 -0.12  0.52 0.25 0.75 1.1
Lozenges               -0.11  0.03  0.70 0.46 0.54 1.1
ParagraphComprehension  0.84  0.00  0.01 0.72 0.28 1.0
SentenceCompletion      0.90  0.01 -0.08 0.76 0.24 1.0
WordMeaning             0.81 -0.01  0.07 0.69 0.31 1.0
SpeedAddition           0.04  0.74 -0.21 0.50 0.50 1.2
SpeedCountingDots      -0.05  0.72  0.05 0.53 0.47 1.0
SpeedDiscrimination     0.01  0.48  0.34 0.46 0.54 1.8

                       ML1  ML2  ML3
SS loadings           2.21 1.33 1.32
Proportion Var        0.25 0.15 0.15
Cumulative Var        0.25 0.39 0.54
Proportion Explained  0.46 0.27 0.27
Cumulative Proportion 0.46 0.73 1.00

 With factor correlations of 
     ML1  ML2  ML3
ML1 1.00 0.26 0.39
ML2 0.26 1.00 0.35
ML3 0.39 0.35 1.00

Mean item complexity =  1.1
Test of the hypothesis that 3 factors are sufficient.

df null model =  36  with the objective function =  3.05 0.3
df of  the model are 12  and the objective function was  0.08 
 0.3
The root mean square of the residuals (RMSR) is  0.02 
The df corrected root mean square of the residuals is  0.03 
 0.3
Fit based upon off diagonal values = 1
Measures of factor score adequacy             
                                                   ML1  ML2  ML3
Correlation of (regression) scores with factors   0.94 0.86 0.85
Multiple R square of scores with factors          0.89 0.74 0.72
Minimum correlation of possible factor scores     0.78 0.47 0.44</code></pre>
</div>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fa.diagram</span>(efa_promax, <span class="at">simple =</span> <span class="cn">FALSE</span>, <span class="at">cut =</span> <span class="fl">0.4</span>, </span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>           <span class="at">main =</span> <span class="st">"EFA with 3 Factors - Promax"</span>, </span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>           <span class="at">errors =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Promax rotation is very similar to varimax at first. It begins by performing a varimax rotation, where the loadings are adjusted to maximize the variance within each factor.</p>
<p>After this, the loadings are raised to a power, which exaggerates the differences: large loadings become much larger, while small ones remain relatively small. This artificially boosts the contrast and creates a <strong>target loading matrix</strong>. This set of loadings is not attainable by the model, but can serve as a target to optimize for.</p>
<p>In the final step, the model lifts the orthogonality requirement, allowing the factors to correlate, and rotates the solution again to come as close as possible to this target structure. In short, promax increases loading contrast even further than varimax, but does so by allowing factor correlation, making it more realistic for psychological data.</p>
</section>
</section>
<section id="model-identification-and-the-trap-of-factor-scores" class="level1">
<h1>Model identification and the trap of factor Scores</h1>
<p>Something worth mentioning is that, while you can use efa_promax$scores to get the factor scores, these scores are not valid. This is because usually, there are multiple solutions to the model (Multiple sets of factor scores and loadings) that produce the same correlation matrix. These factor scores also change when you select different rotations. So don’t use the factor scores as an indicator of a subject’s ability.</p>
</section>
<section id="fitting-the-model-with-other-number-of-factors" class="level1">
<h1>Fitting the model with other number of factors</h1>
<p>Since we know the measurements were designed to have 3 factors in mind, we ran with 3 factors first. However, some times we don’t know the number of factors. Try 2 factors here.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>efa_promax <span class="ot">&lt;-</span> <span class="fu">fa</span>(cor_mat, <span class="at">nfactors =</span> <span class="dv">2</span>, <span class="at">rotate =</span> <span class="st">"promax"</span>, <span class="at">fm =</span> <span class="st">"ml"</span>, <span class="at">covar =</span> <span class="cn">FALSE</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(efa_promax, <span class="at">digits =</span> <span class="dv">2</span>, <span class="at">cutoff =</span> <span class="fl">0.3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Factor Analysis using method =  ml
Call: fa(r = cor_mat, nfactors = 2, rotate = "promax", covar = FALSE, 
    fm = "ml")
Standardized loadings (pattern matrix) based upon correlation matrix
                         ML1   ML2    h2   u2 com
VisualPerception        0.23  0.43 0.327 0.67 1.5
Cubes                   0.09  0.25 0.094 0.91 1.3
Lozenges               -0.01  0.47 0.217 0.78 1.0
ParagraphComprehension  0.87 -0.04 0.726 0.27 1.0
SentenceCompletion      0.89 -0.08 0.736 0.26 1.0
WordMeaning             0.84 -0.01 0.698 0.30 1.0
SpeedAddition          -0.05  0.46 0.198 0.80 1.0
SpeedCountingDots      -0.12  0.65 0.370 0.63 1.1
SpeedDiscrimination    -0.05  0.76 0.542 0.46 1.0

                       ML1  ML2
SS loadings           2.27 1.63
Proportion Var        0.25 0.18
Cumulative Var        0.25 0.43
Proportion Explained  0.58 0.42
Cumulative Proportion 0.58 1.00

 With factor correlations of 
     ML1  ML2
ML1 1.00 0.45
ML2 0.45 1.00

Mean item complexity =  1.1
Test of the hypothesis that 2 factors are sufficient.

df null model =  36  with the objective function =  3.05 0.3
df of  the model are 19  and the objective function was  0.43 
 0.3
The root mean square of the residuals (RMSR) is  0.09 
The df corrected root mean square of the residuals is  0.12 
 0.3
Fit based upon off diagonal values = 0.93
Measures of factor score adequacy             
                                                   ML1  ML2
Correlation of (regression) scores with factors   0.94 0.87
Multiple R square of scores with factors          0.89 0.75
Minimum correlation of possible factor scores     0.78 0.50</code></pre>
</div>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fa.diagram</span>(efa_promax, <span class="at">simple =</span> <span class="cn">FALSE</span>, <span class="at">cut =</span> <span class="fl">0.4</span>, </span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>           <span class="at">main =</span> <span class="st">"EFA with 3 Factors - Promax"</span>, </span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>           <span class="at">errors =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-10-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The loadings are blurry in this case. The cubes measure doesn’t load onto any factor strongly.</p>
<p>Try 4 factors</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>efa_promax <span class="ot">&lt;-</span> <span class="fu">fa</span>(cor_mat, <span class="at">nfactors =</span> <span class="dv">4</span>, <span class="at">rotate =</span> <span class="st">"promax"</span>, <span class="at">fm =</span> <span class="st">"ml"</span>, <span class="at">covar =</span> <span class="cn">FALSE</span>)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(efa_promax, <span class="at">digits =</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Factor Analysis using method =  ml
Call: fa(r = cor_mat, nfactors = 4, rotate = "promax", covar = FALSE, 
    fm = "ml")
Standardized loadings (pattern matrix) based upon correlation matrix
                         ML1   ML3   ML4   ML2   h2    u2 com
VisualPerception        0.15  0.03  0.63 -0.07 0.50 0.503 1.1
Cubes                   0.01 -0.12  0.52  0.03 0.26 0.745 1.1
Lozenges               -0.10  0.04  0.69 -0.07 0.43 0.566 1.1
ParagraphComprehension  0.87  0.01  0.07 -0.28 0.89 0.115 1.2
SentenceCompletion      1.00 -0.02 -0.19  0.38 1.00 0.005 1.4
WordMeaning             0.75  0.00  0.10  0.01 0.62 0.376 1.0
SpeedAddition           0.04  0.80 -0.22 -0.13 0.58 0.421 1.2
SpeedCountingDots      -0.05  0.70  0.05  0.07 0.52 0.485 1.0
SpeedDiscrimination     0.02  0.47  0.33  0.08 0.47 0.529 1.9

                       ML1  ML3  ML4  ML2
SS loadings           2.34 1.35 1.33 0.23
Proportion Var        0.26 0.15 0.15 0.03
Cumulative Var        0.26 0.41 0.56 0.58
Proportion Explained  0.45 0.26 0.25 0.04
Cumulative Proportion 0.45 0.70 0.96 1.00

 With factor correlations of 
      ML1  ML3  ML4   ML2
ML1  1.00 0.24 0.37 -0.02
ML3  0.24 1.00 0.35  0.11
ML4  0.37 0.35 1.00  0.23
ML2 -0.02 0.11 0.23  1.00

Mean item complexity =  1.2
Test of the hypothesis that 4 factors are sufficient.

df null model =  36  with the objective function =  3.05
df of  the model are 6  and the objective function was  0.02 

The root mean square of the residuals (RMSR) is  0.01 
The df corrected root mean square of the residuals is  0.03 

Fit based upon off diagonal values = 1
Measures of factor score adequacy             
                                                   ML1  ML3  ML4  ML2
Correlation of (regression) scores with factors   0.98 0.87 0.85 0.86
Multiple R square of scores with factors          0.97 0.75 0.72 0.74
Minimum correlation of possible factor scores     0.93 0.51 0.44 0.49</code></pre>
</div>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fa.diagram</span>(efa_promax, <span class="at">simple =</span> <span class="cn">FALSE</span>, <span class="at">cut =</span> <span class="fl">0.4</span>, </span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>           <span class="at">main =</span> <span class="st">"EFA with 3 Factors - Promax"</span>, </span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>           <span class="at">errors =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/unnamed-chunk-11-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Simple structure is only present in the first 3 factors. The 4th factor does not explain much common variance in the measures.</p>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>So, it is clear that the 3 factor model is the representation of what those measurements are measuring.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>